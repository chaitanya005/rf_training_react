{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst prosemirror_keymap_1 = require(\"prosemirror-keymap\");\n\nconst prosemirror_markdown_1 = require(\"prosemirror-markdown\");\n\nconst serializer_1 = require(\"./markdown/serializer\");\n\nconst rules_1 = __importDefault(require(\"./markdown/rules\"));\n\nclass ExtensionManager {\n  constructor() {\n    let extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let editor = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (editor) {\n      extensions.forEach(extension => {\n        extension.bindEditor(editor);\n      });\n    }\n\n    this.extensions = extensions;\n  }\n\n  get nodes() {\n    return this.extensions.filter(extension => extension.type === \"node\").reduce((nodes, node) => Object.assign(Object.assign({}, nodes), {\n      [node.name]: node.schema\n    }), {});\n  }\n\n  serializer() {\n    const nodes = this.extensions.filter(extension => extension.type === \"node\").reduce((nodes, extension) => Object.assign(Object.assign({}, nodes), {\n      [extension.name]: extension.toMarkdown\n    }), {});\n    const marks = this.extensions.filter(extension => extension.type === \"mark\").reduce((marks, extension) => Object.assign(Object.assign({}, marks), {\n      [extension.name]: extension.toMarkdown\n    }), {});\n    return new serializer_1.MarkdownSerializer(nodes, marks);\n  }\n\n  parser(_ref) {\n    let {\n      schema,\n      rules,\n      plugins\n    } = _ref;\n    const tokens = this.extensions.filter(extension => extension.type === \"mark\" || extension.type === \"node\").reduce((nodes, extension) => {\n      const md = extension.parseMarkdown();\n      if (!md) return nodes;\n      return Object.assign(Object.assign({}, nodes), {\n        [extension.markdownToken || extension.name]: md\n      });\n    }, {});\n    return new prosemirror_markdown_1.MarkdownParser(schema, rules_1.default({\n      rules,\n      plugins\n    }), tokens);\n  }\n\n  get marks() {\n    return this.extensions.filter(extension => extension.type === \"mark\").reduce((marks, _ref2) => {\n      let {\n        name,\n        schema\n      } = _ref2;\n      return Object.assign(Object.assign({}, marks), {\n        [name]: schema\n      });\n    }, {});\n  }\n\n  get plugins() {\n    return this.extensions.filter(extension => \"plugins\" in extension).reduce((allPlugins, _ref3) => {\n      let {\n        plugins\n      } = _ref3;\n      return [...allPlugins, ...plugins];\n    }, []);\n  }\n\n  get rulePlugins() {\n    return this.extensions.filter(extension => \"rulePlugins\" in extension).reduce((allRulePlugins, _ref4) => {\n      let {\n        rulePlugins\n      } = _ref4;\n      return [...allRulePlugins, ...rulePlugins];\n    }, []);\n  }\n\n  keymaps(_ref5) {\n    let {\n      schema\n    } = _ref5;\n    const extensionKeymaps = this.extensions.filter(extension => [\"extension\"].includes(extension.type)).filter(extension => extension.keys).map(extension => extension.keys({\n      schema\n    }));\n    const nodeMarkKeymaps = this.extensions.filter(extension => [\"node\", \"mark\"].includes(extension.type)).filter(extension => extension.keys).map(extension => extension.keys({\n      type: schema[`${extension.type}s`][extension.name],\n      schema\n    }));\n    return [...extensionKeymaps, ...nodeMarkKeymaps].map(keys => prosemirror_keymap_1.keymap(keys));\n  }\n\n  inputRules(_ref6) {\n    let {\n      schema\n    } = _ref6;\n    const extensionInputRules = this.extensions.filter(extension => [\"extension\"].includes(extension.type)).filter(extension => extension.inputRules).map(extension => extension.inputRules({\n      schema\n    }));\n    const nodeMarkInputRules = this.extensions.filter(extension => [\"node\", \"mark\"].includes(extension.type)).filter(extension => extension.inputRules).map(extension => extension.inputRules({\n      type: schema[`${extension.type}s`][extension.name],\n      schema\n    }));\n    return [...extensionInputRules, ...nodeMarkInputRules].reduce((allInputRules, inputRules) => [...allInputRules, ...inputRules], []);\n  }\n\n  commands(_ref7) {\n    let {\n      schema,\n      view\n    } = _ref7;\n    return this.extensions.filter(extension => extension.commands).reduce((allCommands, extension) => {\n      const {\n        name,\n        type\n      } = extension;\n      const commands = {};\n      const value = extension.commands(Object.assign({\n        schema\n      }, [\"node\", \"mark\"].includes(type) ? {\n        type: schema[`${type}s`][name]\n      } : {}));\n\n      const apply = (callback, attrs) => {\n        if (!view.editable) {\n          return false;\n        }\n\n        view.focus();\n        return callback(attrs)(view.state, view.dispatch, view);\n      };\n\n      const handle = (_name, _value) => {\n        if (Array.isArray(_value)) {\n          commands[_name] = attrs => _value.forEach(callback => apply(callback, attrs));\n        } else if (typeof _value === \"function\") {\n          commands[_name] = attrs => apply(_value, attrs);\n        }\n      };\n\n      if (typeof value === \"object\") {\n        Object.entries(value).forEach(_ref8 => {\n          let [commandName, commandValue] = _ref8;\n          handle(commandName, commandValue);\n        });\n      } else {\n        handle(name, value);\n      }\n\n      return Object.assign(Object.assign({}, allCommands), commands);\n    }, {});\n  }\n\n}\n\nexports.default = ExtensionManager;","map":{"version":3,"sources":["../../src/lib/ExtensionManager.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst prosemirror_keymap_1 = require(\"prosemirror-keymap\");\nconst prosemirror_markdown_1 = require(\"prosemirror-markdown\");\nconst serializer_1 = require(\"./markdown/serializer\");\nconst rules_1 = __importDefault(require(\"./markdown/rules\"));\nclass ExtensionManager {\n    constructor(extensions = [], editor) {\n        if (editor) {\n            extensions.forEach(extension => {\n                extension.bindEditor(editor);\n            });\n        }\n        this.extensions = extensions;\n    }\n    get nodes() {\n        return this.extensions\n            .filter(extension => extension.type === \"node\")\n            .reduce((nodes, node) => (Object.assign(Object.assign({}, nodes), { [node.name]: node.schema })), {});\n    }\n    serializer() {\n        const nodes = this.extensions\n            .filter(extension => extension.type === \"node\")\n            .reduce((nodes, extension) => (Object.assign(Object.assign({}, nodes), { [extension.name]: extension.toMarkdown })), {});\n        const marks = this.extensions\n            .filter(extension => extension.type === \"mark\")\n            .reduce((marks, extension) => (Object.assign(Object.assign({}, marks), { [extension.name]: extension.toMarkdown })), {});\n        return new serializer_1.MarkdownSerializer(nodes, marks);\n    }\n    parser({ schema, rules, plugins, }) {\n        const tokens = this.extensions\n            .filter(extension => extension.type === \"mark\" || extension.type === \"node\")\n            .reduce((nodes, extension) => {\n            const md = extension.parseMarkdown();\n            if (!md)\n                return nodes;\n            return Object.assign(Object.assign({}, nodes), { [extension.markdownToken || extension.name]: md });\n        }, {});\n        return new prosemirror_markdown_1.MarkdownParser(schema, rules_1.default({ rules, plugins }), tokens);\n    }\n    get marks() {\n        return this.extensions\n            .filter(extension => extension.type === \"mark\")\n            .reduce((marks, { name, schema }) => (Object.assign(Object.assign({}, marks), { [name]: schema })), {});\n    }\n    get plugins() {\n        return this.extensions\n            .filter(extension => \"plugins\" in extension)\n            .reduce((allPlugins, { plugins }) => [...allPlugins, ...plugins], []);\n    }\n    get rulePlugins() {\n        return this.extensions\n            .filter(extension => \"rulePlugins\" in extension)\n            .reduce((allRulePlugins, { rulePlugins }) => [\n            ...allRulePlugins,\n            ...rulePlugins,\n        ], []);\n    }\n    keymaps({ schema }) {\n        const extensionKeymaps = this.extensions\n            .filter(extension => [\"extension\"].includes(extension.type))\n            .filter(extension => extension.keys)\n            .map(extension => extension.keys({ schema }));\n        const nodeMarkKeymaps = this.extensions\n            .filter(extension => [\"node\", \"mark\"].includes(extension.type))\n            .filter(extension => extension.keys)\n            .map(extension => extension.keys({\n            type: schema[`${extension.type}s`][extension.name],\n            schema,\n        }));\n        return [\n            ...extensionKeymaps,\n            ...nodeMarkKeymaps,\n        ].map((keys) => prosemirror_keymap_1.keymap(keys));\n    }\n    inputRules({ schema }) {\n        const extensionInputRules = this.extensions\n            .filter(extension => [\"extension\"].includes(extension.type))\n            .filter(extension => extension.inputRules)\n            .map(extension => extension.inputRules({ schema }));\n        const nodeMarkInputRules = this.extensions\n            .filter(extension => [\"node\", \"mark\"].includes(extension.type))\n            .filter(extension => extension.inputRules)\n            .map(extension => extension.inputRules({\n            type: schema[`${extension.type}s`][extension.name],\n            schema,\n        }));\n        return [...extensionInputRules, ...nodeMarkInputRules].reduce((allInputRules, inputRules) => [...allInputRules, ...inputRules], []);\n    }\n    commands({ schema, view }) {\n        return this.extensions\n            .filter(extension => extension.commands)\n            .reduce((allCommands, extension) => {\n            const { name, type } = extension;\n            const commands = {};\n            const value = extension.commands(Object.assign({ schema }, ([\"node\", \"mark\"].includes(type)\n                ? {\n                    type: schema[`${type}s`][name],\n                }\n                : {})));\n            const apply = (callback, attrs) => {\n                if (!view.editable) {\n                    return false;\n                }\n                view.focus();\n                return callback(attrs)(view.state, view.dispatch, view);\n            };\n            const handle = (_name, _value) => {\n                if (Array.isArray(_value)) {\n                    commands[_name] = attrs => _value.forEach(callback => apply(callback, attrs));\n                }\n                else if (typeof _value === \"function\") {\n                    commands[_name] = attrs => apply(_value, attrs);\n                }\n            };\n            if (typeof value === \"object\") {\n                Object.entries(value).forEach(([commandName, commandValue]) => {\n                    handle(commandName, commandValue);\n                });\n            }\n            else {\n                handle(name, value);\n            }\n            return Object.assign(Object.assign({}, allCommands), commands);\n        }, {});\n    }\n}\nexports.default = ExtensionManager;\n"]},"metadata":{},"sourceType":"script"}