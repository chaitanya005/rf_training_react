{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Node_1 = __importDefault(require(\"./Node\"));\n\nconst prosemirror_view_1 = require(\"prosemirror-view\");\n\nconst prosemirror_tables_1 = require(\"prosemirror-tables\");\n\nconst prosemirror_utils_1 = require(\"prosemirror-utils\");\n\nconst prosemirror_state_1 = require(\"prosemirror-state\");\n\nconst tables_1 = __importDefault(require(\"../rules/tables\"));\n\nclass Table extends Node_1.default {\n  get name() {\n    return \"table\";\n  }\n\n  get schema() {\n    return {\n      content: \"tr+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: \"block\",\n      parseDOM: [{\n        tag: \"table\"\n      }],\n\n      toDOM() {\n        return [\"div\", {\n          class: \"scrollable-wrapper\"\n        }, [\"div\", {\n          class: \"scrollable\"\n        }, [\"table\", {\n          class: \"rme-table\"\n        }, [\"tbody\", 0]]]];\n      }\n\n    };\n  }\n\n  get rulePlugins() {\n    return [tables_1.default];\n  }\n\n  commands(_ref) {\n    let {\n      schema\n    } = _ref;\n    return {\n      createTable: _ref2 => {\n        let {\n          rowsCount,\n          colsCount\n        } = _ref2;\n        return (state, dispatch) => {\n          const offset = state.tr.selection.anchor + 1;\n          const nodes = prosemirror_utils_1.createTable(schema, rowsCount, colsCount);\n          const tr = state.tr.replaceSelectionWith(nodes).scrollIntoView();\n          const resolvedPos = tr.doc.resolve(offset);\n          tr.setSelection(prosemirror_state_1.TextSelection.near(resolvedPos));\n          dispatch(tr);\n        };\n      },\n      setColumnAttr: _ref3 => {\n        let {\n          index,\n          alignment\n        } = _ref3;\n        return (state, dispatch) => {\n          const cells = prosemirror_utils_1.getCellsInColumn(index)(state.selection) || [];\n          let transaction = state.tr;\n          cells.forEach(_ref4 => {\n            let {\n              pos\n            } = _ref4;\n            transaction = transaction.setNodeMarkup(pos, null, {\n              alignment\n            });\n          });\n          dispatch(transaction);\n        };\n      },\n      addColumnBefore: () => prosemirror_tables_1.addColumnBefore,\n      addColumnAfter: () => prosemirror_tables_1.addColumnAfter,\n      deleteColumn: () => prosemirror_tables_1.deleteColumn,\n      addRowAfter: _ref5 => {\n        let {\n          index\n        } = _ref5;\n        return (state, dispatch) => {\n          if (index === 0) {\n            const tr = prosemirror_utils_1.addRowAt(index + 2, true)(state.tr);\n            dispatch(prosemirror_utils_1.moveRow(index + 2, index + 1)(tr));\n          } else {\n            dispatch(prosemirror_utils_1.addRowAt(index + 1, true)(state.tr));\n          }\n        };\n      },\n      deleteRow: () => prosemirror_tables_1.deleteRow,\n      deleteTable: () => prosemirror_tables_1.deleteTable,\n      toggleHeaderColumn: () => prosemirror_tables_1.toggleHeaderColumn,\n      toggleHeaderRow: () => prosemirror_tables_1.toggleHeaderRow,\n      toggleHeaderCell: () => prosemirror_tables_1.toggleHeaderCell,\n      setCellAttr: () => prosemirror_tables_1.setCellAttr,\n      fixTables: () => prosemirror_tables_1.fixTables\n    };\n  }\n\n  keys() {\n    return {\n      Tab: prosemirror_tables_1.goToNextCell(1),\n      \"Shift-Tab\": prosemirror_tables_1.goToNextCell(-1),\n      Enter: (state, dispatch) => {\n        if (!prosemirror_tables_1.isInTable(state)) return false;\n        const cells = prosemirror_utils_1.getCellsInColumn(0)(state.selection) || [];\n        dispatch(prosemirror_utils_1.addRowAt(cells.length, true)(state.tr));\n        return true;\n      }\n    };\n  }\n\n  toMarkdown(state, node) {\n    state.renderTable(node);\n    state.closeBlock(node);\n  }\n\n  parseMarkdown() {\n    return {\n      block: \"table\"\n    };\n  }\n\n  get plugins() {\n    return [prosemirror_tables_1.tableEditing(), new prosemirror_state_1.Plugin({\n      props: {\n        decorations: state => {\n          const {\n            doc\n          } = state;\n          const decorations = [];\n          let index = 0;\n          doc.descendants((node, pos) => {\n            if (node.type.name !== this.name) return;\n            const elements = document.getElementsByClassName(\"rme-table\");\n            const table = elements[index];\n            if (!table) return;\n            const element = table.parentElement;\n            const shadowRight = !!(element && element.scrollWidth > element.clientWidth);\n\n            if (shadowRight) {\n              decorations.push(prosemirror_view_1.Decoration.widget(pos + 1, () => {\n                const shadow = document.createElement(\"div\");\n                shadow.className = \"scrollable-shadow right\";\n                return shadow;\n              }));\n            }\n\n            index++;\n          });\n          return prosemirror_view_1.DecorationSet.create(doc, decorations);\n        }\n      }\n    })];\n  }\n\n}\n\nexports.default = Table;","map":{"version":3,"sources":["../../src/nodes/Table.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Node_1 = __importDefault(require(\"./Node\"));\nconst prosemirror_view_1 = require(\"prosemirror-view\");\nconst prosemirror_tables_1 = require(\"prosemirror-tables\");\nconst prosemirror_utils_1 = require(\"prosemirror-utils\");\nconst prosemirror_state_1 = require(\"prosemirror-state\");\nconst tables_1 = __importDefault(require(\"../rules/tables\"));\nclass Table extends Node_1.default {\n    get name() {\n        return \"table\";\n    }\n    get schema() {\n        return {\n            content: \"tr+\",\n            tableRole: \"table\",\n            isolating: true,\n            group: \"block\",\n            parseDOM: [{ tag: \"table\" }],\n            toDOM() {\n                return [\n                    \"div\",\n                    { class: \"scrollable-wrapper\" },\n                    [\n                        \"div\",\n                        { class: \"scrollable\" },\n                        [\"table\", { class: \"rme-table\" }, [\"tbody\", 0]],\n                    ],\n                ];\n            },\n        };\n    }\n    get rulePlugins() {\n        return [tables_1.default];\n    }\n    commands({ schema }) {\n        return {\n            createTable: ({ rowsCount, colsCount }) => (state, dispatch) => {\n                const offset = state.tr.selection.anchor + 1;\n                const nodes = prosemirror_utils_1.createTable(schema, rowsCount, colsCount);\n                const tr = state.tr.replaceSelectionWith(nodes).scrollIntoView();\n                const resolvedPos = tr.doc.resolve(offset);\n                tr.setSelection(prosemirror_state_1.TextSelection.near(resolvedPos));\n                dispatch(tr);\n            },\n            setColumnAttr: ({ index, alignment }) => (state, dispatch) => {\n                const cells = prosemirror_utils_1.getCellsInColumn(index)(state.selection) || [];\n                let transaction = state.tr;\n                cells.forEach(({ pos }) => {\n                    transaction = transaction.setNodeMarkup(pos, null, {\n                        alignment,\n                    });\n                });\n                dispatch(transaction);\n            },\n            addColumnBefore: () => prosemirror_tables_1.addColumnBefore,\n            addColumnAfter: () => prosemirror_tables_1.addColumnAfter,\n            deleteColumn: () => prosemirror_tables_1.deleteColumn,\n            addRowAfter: ({ index }) => (state, dispatch) => {\n                if (index === 0) {\n                    const tr = prosemirror_utils_1.addRowAt(index + 2, true)(state.tr);\n                    dispatch(prosemirror_utils_1.moveRow(index + 2, index + 1)(tr));\n                }\n                else {\n                    dispatch(prosemirror_utils_1.addRowAt(index + 1, true)(state.tr));\n                }\n            },\n            deleteRow: () => prosemirror_tables_1.deleteRow,\n            deleteTable: () => prosemirror_tables_1.deleteTable,\n            toggleHeaderColumn: () => prosemirror_tables_1.toggleHeaderColumn,\n            toggleHeaderRow: () => prosemirror_tables_1.toggleHeaderRow,\n            toggleHeaderCell: () => prosemirror_tables_1.toggleHeaderCell,\n            setCellAttr: () => prosemirror_tables_1.setCellAttr,\n            fixTables: () => prosemirror_tables_1.fixTables,\n        };\n    }\n    keys() {\n        return {\n            Tab: prosemirror_tables_1.goToNextCell(1),\n            \"Shift-Tab\": prosemirror_tables_1.goToNextCell(-1),\n            Enter: (state, dispatch) => {\n                if (!prosemirror_tables_1.isInTable(state))\n                    return false;\n                const cells = prosemirror_utils_1.getCellsInColumn(0)(state.selection) || [];\n                dispatch(prosemirror_utils_1.addRowAt(cells.length, true)(state.tr));\n                return true;\n            },\n        };\n    }\n    toMarkdown(state, node) {\n        state.renderTable(node);\n        state.closeBlock(node);\n    }\n    parseMarkdown() {\n        return { block: \"table\" };\n    }\n    get plugins() {\n        return [\n            prosemirror_tables_1.tableEditing(),\n            new prosemirror_state_1.Plugin({\n                props: {\n                    decorations: state => {\n                        const { doc } = state;\n                        const decorations = [];\n                        let index = 0;\n                        doc.descendants((node, pos) => {\n                            if (node.type.name !== this.name)\n                                return;\n                            const elements = document.getElementsByClassName(\"rme-table\");\n                            const table = elements[index];\n                            if (!table)\n                                return;\n                            const element = table.parentElement;\n                            const shadowRight = !!(element && element.scrollWidth > element.clientWidth);\n                            if (shadowRight) {\n                                decorations.push(prosemirror_view_1.Decoration.widget(pos + 1, () => {\n                                    const shadow = document.createElement(\"div\");\n                                    shadow.className = \"scrollable-shadow right\";\n                                    return shadow;\n                                }));\n                            }\n                            index++;\n                        });\n                        return prosemirror_view_1.DecorationSet.create(doc, decorations);\n                    },\n                },\n            }),\n        ];\n    }\n}\nexports.default = Table;\n"]},"metadata":{},"sourceType":"script"}