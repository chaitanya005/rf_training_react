{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst prosemirror_inputrules_1 = require(\"prosemirror-inputrules\");\n\nconst name_to_emoji_json_1 = __importDefault(require(\"gemoji/name-to-emoji.json\"));\n\nconst Node_1 = __importDefault(require(\"./Node\"));\n\nconst emoji_1 = __importDefault(require(\"../rules/emoji\"));\n\nclass Emoji extends Node_1.default {\n  get name() {\n    return \"emoji\";\n  }\n\n  get schema() {\n    return {\n      attrs: {\n        style: {\n          default: \"\"\n        },\n        \"data-name\": {\n          default: undefined\n        }\n      },\n      inline: true,\n      content: \"text*\",\n      marks: \"\",\n      group: \"inline\",\n      selectable: false,\n      parseDOM: [{\n        tag: \"span.emoji\",\n        preserveWhitespace: \"full\",\n        getAttrs: dom => ({\n          \"data-name\": dom.dataset.name\n        })\n      }],\n      toDOM: node => {\n        if (name_to_emoji_json_1.default[node.attrs[\"data-name\"]]) {\n          const text = document.createTextNode(name_to_emoji_json_1.default[node.attrs[\"data-name\"]]);\n          return [\"span\", {\n            class: `emoji ${node.attrs[\"data-name\"]}`,\n            \"data-name\": node.attrs[\"data-name\"]\n          }, text];\n        }\n\n        const text = document.createTextNode(`:${node.attrs[\"data-name\"]}:`);\n        return [\"span\", {\n          class: \"emoji\"\n        }, text];\n      }\n    };\n  }\n\n  get rulePlugins() {\n    return [emoji_1.default];\n  }\n\n  commands(_ref) {\n    let {\n      type\n    } = _ref;\n    return attrs => (state, dispatch) => {\n      const {\n        selection\n      } = state;\n      const position = selection.$cursor ? selection.$cursor.pos : selection.$to.pos;\n      const node = type.create(attrs);\n      const transaction = state.tr.insert(position, node);\n      dispatch(transaction);\n      return true;\n    };\n  }\n\n  inputRules(_ref2) {\n    let {\n      type\n    } = _ref2;\n    return [new prosemirror_inputrules_1.InputRule(/^\\:([a-zA-Z0-9_+-]+)\\:$/, (state, match, start, end) => {\n      const [okay, markup] = match;\n      const {\n        tr\n      } = state;\n\n      if (okay) {\n        tr.replaceWith(start - 1, end, type.create({\n          \"data-name\": markup,\n          markup\n        }));\n      }\n\n      return tr;\n    })];\n  }\n\n  toMarkdown(state, node) {\n    const name = node.attrs[\"data-name\"];\n\n    if (name) {\n      state.write(`:${name}:`);\n    }\n  }\n\n  parseMarkdown() {\n    return {\n      node: \"emoji\",\n      getAttrs: tok => {\n        return {\n          \"data-name\": tok.markup.trim()\n        };\n      }\n    };\n  }\n\n}\n\nexports.default = Emoji;","map":{"version":3,"sources":["../../src/nodes/Emoji.tsx"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst prosemirror_inputrules_1 = require(\"prosemirror-inputrules\");\nconst name_to_emoji_json_1 = __importDefault(require(\"gemoji/name-to-emoji.json\"));\nconst Node_1 = __importDefault(require(\"./Node\"));\nconst emoji_1 = __importDefault(require(\"../rules/emoji\"));\nclass Emoji extends Node_1.default {\n    get name() {\n        return \"emoji\";\n    }\n    get schema() {\n        return {\n            attrs: {\n                style: {\n                    default: \"\",\n                },\n                \"data-name\": {\n                    default: undefined,\n                },\n            },\n            inline: true,\n            content: \"text*\",\n            marks: \"\",\n            group: \"inline\",\n            selectable: false,\n            parseDOM: [\n                {\n                    tag: \"span.emoji\",\n                    preserveWhitespace: \"full\",\n                    getAttrs: (dom) => ({\n                        \"data-name\": dom.dataset.name,\n                    }),\n                },\n            ],\n            toDOM: node => {\n                if (name_to_emoji_json_1.default[node.attrs[\"data-name\"]]) {\n                    const text = document.createTextNode(name_to_emoji_json_1.default[node.attrs[\"data-name\"]]);\n                    return [\n                        \"span\",\n                        {\n                            class: `emoji ${node.attrs[\"data-name\"]}`,\n                            \"data-name\": node.attrs[\"data-name\"],\n                        },\n                        text,\n                    ];\n                }\n                const text = document.createTextNode(`:${node.attrs[\"data-name\"]}:`);\n                return [\"span\", { class: \"emoji\" }, text];\n            },\n        };\n    }\n    get rulePlugins() {\n        return [emoji_1.default];\n    }\n    commands({ type }) {\n        return attrs => (state, dispatch) => {\n            const { selection } = state;\n            const position = selection.$cursor\n                ? selection.$cursor.pos\n                : selection.$to.pos;\n            const node = type.create(attrs);\n            const transaction = state.tr.insert(position, node);\n            dispatch(transaction);\n            return true;\n        };\n    }\n    inputRules({ type }) {\n        return [\n            new prosemirror_inputrules_1.InputRule(/^\\:([a-zA-Z0-9_+-]+)\\:$/, (state, match, start, end) => {\n                const [okay, markup] = match;\n                const { tr } = state;\n                if (okay) {\n                    tr.replaceWith(start - 1, end, type.create({\n                        \"data-name\": markup,\n                        markup,\n                    }));\n                }\n                return tr;\n            }),\n        ];\n    }\n    toMarkdown(state, node) {\n        const name = node.attrs[\"data-name\"];\n        if (name) {\n            state.write(`:${name}:`);\n        }\n    }\n    parseMarkdown() {\n        return {\n            node: \"emoji\",\n            getAttrs: tok => {\n                return { \"data-name\": tok.markup.trim() };\n            },\n        };\n    }\n}\nexports.default = Emoji;\n"]},"metadata":{},"sourceType":"script"}